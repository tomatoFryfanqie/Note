### 3. 面向对象（上）

#### 类

##### 类的定义

```java
// 修饰符可以是 public final abstract
[修饰符] class 类名{
	//零到多个构造器定义;
    [修饰符] 构造器名(形参列表){
        // 由零条和多条可执行语句组成的构造器执行体
    }
	//零到多个成员变量;
    [修饰符] 类型 成员变量名 [= 默认值];
    //零到多个方法;
    [修饰符] 方法返回值类型 方法名(形参列表){
        //由零到多条可执行语句组成的方法体
    }
}
```

##### 类的权限修饰符

需要注意的是： `protected` 和 `private` 在类这一层次只能修饰内部类。 `default` 不可修饰类，会引发语法错误。使用 `default` 权限，类前不加修饰符即可。

|  修饰符   | 本类 | 同一包下 | 子类 | 全局 |
| :-------: | :--: | :------: | :--: | :--: |
|  public   |  √   |    √     |  √   |  √   |
| protected |  √   |    √     |  √   |      |
|  default  |  √   |    √     |      |      |
|  private  |  √   |          |      |      |

其他类修饰符：

|  修饰符  |       作用       |
| :------: | :--------------: |
| abstract | 修饰该类为抽象类 |
|  final   | 修饰该类为最终类 |
|   enum   | 修饰该类为枚举类 |



##### 对象的产生

创建对象的根本途径是构造器，通过 `new` 关键字来调用某个类的构造器，即可创建这个类的实例。

```java
Person wangxing = new Person();
```

##### this

`this` 关键字总是指向调用该方法的对象。根据 `this` 出现位置的不同，`this` 作为对象的默认引用有两种情形。

>构造器中引用该构造器正在初始化的对象

>在方法中引用调用该方法的对象

##### super

`super` 关键字用于调用父类被覆盖的实例方法。

#### ==**面向对象的三大特征：**==

##### 封装

​	它是指将对象的状态信息隐藏在对象内部，不允许外界程序直接访问对象内部的信息，而是通过该对象提供的方法来实现对内部信息的访问和操作。

##### 继承

​	实现代码复用的一种重要手段。( Java的继承具有单继承的特点，每个子类只有一个直接父类。)

##### 多态

​	Java引用变量有两个类型：一个是编译时类型，一个是运行时类型。

​	编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。

​	如果编译时类型和运行时类型不一致，就可能出现所谓的多态。

#### ==**注意点:**==

1. 对于 `static` 修饰的方法而言，则可以使用类来直接调用该方法。如果static修饰的方法中使用 `this` 关键字，则这个关键字就无法指向合适的对象。所以，`static` 修饰的方法中不能使用 `this` 引用。由于 `static` 修饰的方法不能使用 `this` 引用，所以 `static` 修饰的方法不能访问不适用 `static` 修饰的普通成员，因此 Java语法规定：**静态成员不能直接访问非静态成员**。

2. Java方法的参数传递方式只有一种：**值传递**。

3. 方法重载：在同一个类中，方法名相同，参数列表不同。

   方法重写：发生在继承的类中，方法名相同，参数列表相同。（**注意：** 子类方法返回值类型和抛出的异常应该比父类方法返回值类型更小，或相等）。

4. 如果程序员没有为Java类提供任何构造器，则系统会为这个类提供一个无参数的构造器，这个构造器的执行体为空，不做任何事情。无论如何，Java类至少包含一个构造器。

5. 子类只能从被继承的父类获得成员变量，方法和内部类(包括内部接口，枚举)，不能获得构造器和初始化块。

6. 当调用子类构造器来初始化子类对象时，父类构造器总会在子类构造器之前执行。因此，最先执行的总是java.lang.Object类的构造器。

7. 引用类型之间的转换只能在具有继承关系的两个类型之间进行，如果两个没有任何继承关系的类型，则无法进行类型转换。如果试图把一个父类实例转换成子类类型，则这个实例必须实际上是子类实例才可以。

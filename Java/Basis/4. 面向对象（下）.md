### 4. 面向对象（下）



#### ==与equals

##### ==

**基本类型** 比较其数值是否相同

**对象** 比较其引用的地址是否相同

##### equals

所有类的equals方法均继承Object类的equals方法.其源代码:

```java
public boolean equals(Object obj) {
	return (this == obj);
}
```

效果与 == 相同
**因此,使用equals方法时,注意有没有被重写**



#### 抽象类

抽象类和抽象方法必须使用 `abstract` 修饰。

**抽象规则**

>抽象类，抽象方法必须使用abstract修饰符修饰，抽象方法不能有方法体。

>抽象类不能被实例化，无法使用new关键字来调用抽象类的构造器创建抽象类的实例。

> 抽象类可以包含成员变量，方法（普通方法和抽象方法都可以），构造器，初始化块，内部类（接口，枚举）5种成分。构造器不能用于创建实例，主要用于被子类调用。

> 含有抽象方法的类（包括直接定义了一个抽象方法；或继承了一个抽象父类，但没有完全实父类的抽象方法；或实现了一个接口，但没有完全实现接口包含的抽象方法三种情况。）只能被定义为抽象类。



#### 接口

##### 接口的定义

```java
[修饰符] interface 接口名 extends 父接口1, 父接口2{
	//零到多个常量定义
	//零到多个抽象方法定义
	//零到多个内部类，接口，枚举定义
	//零到多个私有方法,默认方法或类方法定义
} 
```



#### 匿名内部类

##### 匿名内部类的定义

```java
new 实现接口() | 父类构造器(实参列表){
	//匿名内部类的类体
}
```

**规则：**

> 匿名内部类不能是抽象类，因为系统在创建匿名内部类时，会立即创建匿名内部类的对象。因此不允许将匿名内部类定义为抽象类。

> 匿名内部类不能定义构造器。由于匿名内部类没有类名，所以无法定义构造器，但匿名内部类可以定义初始化块，可以通过实例初始化块来完成构造器需要完成的事情。



#### ==**注意点:**==

1. Java会把一个 -128 ~ 127之间的整数自动装箱成 `Integer` 实例，并放入一个cache数组缓存起来.

2. `static` 和 `abstract` 并不是决定互斥的 `static` 和 `abstract` 不能同时修饰某个方法，但它们可以同时修饰内部类。

3. `abstract` 关键字修饰的方法必须被其子类重写才有意义，否则这个方法将永远不会有方法体。因此 `abstract` 修饰的方法不能使用 `private` 修饰。即 `private`  `abstract` 不能同时出现。

4. Java会自动为接口里定义的成员变量增加 `public static final` 修饰符。

5. 接口里不加修饰符的方法，Java会自动为接口定义的普通方法增加 `public abstract` 修饰符。

6. 接口里定义的内部类，内部接口，内部枚举默认都采用 `public static` 修饰符.

7. 接口与抽象类：

   相同点：

   > 接口与抽象类都不能被实例化，它们都位于继承树的顶端，用于被其他类实现和继承。

   > 接口和抽象类都可以包含抽象方法。

   差异：

   > 接口里只能包含抽象方法，静态方法，默认方法和私有方法，不能为普通方法提供方法实现。
   >
   > 抽象类可以包含普通方法。

   > 接口里只能定义静态常量，不能定义普通成员变量；
   >
   > 抽象类里面既可以定义静态常量，也可以定义普通变量。

   > 接口里不包含构造器；
   >
   > 抽象类可以包含构造器；

   >接口不包含初始化块；
   >
   >抽象类可以包含初始化块；

   > 一个类最多只有一个直接父类，包含抽象类。但是一个类可以实现多个接口，通过实现多个接口可以弥补Java单继承的不足。

8. 内部类比外部类可以多使用三个修饰符： `private，protect static`
